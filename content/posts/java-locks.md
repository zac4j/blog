---
title: "Java Locks"
date: 2022-05-09T19:53:23+08:00
tags: ["locks", "synchronized"]
description: "Java 中的各种锁(非 Lock 接口)"
categories: ["java", "concurrent"]
author: "Zac"
draft: true
---

Java 对一个对象加锁，锁是什么东西？
什么是锁竞争？

+ 如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。

## 悲观锁与乐观锁

悲观锁阻塞事务，乐观锁回滚重试

+ 悲观锁
  + 每次拿数据时都认为别人会修改，所以每次拿数据都会上锁，这样别人想拿数据就会被挡住，直到悲观锁被释放。
+ 乐观锁
  + 每次拿数据都认为别人不会修改，所以不会上锁，但是想要更新数据时，会在更新前检查从读取到更新这段时间数据是否被别人修改过。如果修改过，则重新读取，再次尝试更新，循环上述步骤直到更新成功。
  + 伪代码：
  
  ``` java
  var data = 111;
  var flag = true;

  while(flag) {
    val oldValue = data;
    val newValue = modify(data);
    // CAS = Compare-and-Swap 比较并替换
    if(data == oldValue) {
      data = newValue;
      flag = false;
    } else {
      // do nothing
    }
  }
  ```

因为整个过程并没有加锁-解锁的操作，因此乐观锁策略也被称为无锁编程，它仅仅是一个循环重试CAS算法而已。

自旋锁

所谓自旋，就是一个 while(true) 无限循环，当然和乐观锁不同哈

synchronized 锁升级：偏向锁 -> 轻量级锁 -> 重量级锁

初次执行 synchronized 代码块时，锁对象变成偏向锁（通过 CAS 修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行同步代码块后，线程并不会主动释放偏向锁。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否为自己（对象头里也含有持有锁的线程 ID），如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。

一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）。在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过 CAS 修改对象头里的锁标识位。先比较当前锁标识位是否为“释放”，如果是则将其设置为“锁定”，比较并设置是原子性发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。

长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗 CPU，执行不了任何有效的任务，这种现象叫忙等（busy-waiting）。如果多个线程用一个锁，但是没有发生锁竞争，或者发生很轻微的锁竞争，那么 synchronized 就用轻量级锁，允许短时间的忙等现象。这是一种折中的做法，短时间的忙等，换取线程在用户态（user mode）和内核态（kernel mode）之间切换的开销。

显然，忙等也是有限度的（有个计数器记录自旋次数，默认允许循环10次）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁（依然是 CAS 修改锁标志位，但不修改持有锁的线程 ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。一个锁只能按照偏向锁、轻量级锁、重量级锁的顺序循序升级（也有叫锁膨胀的），不允许降级。

可重入锁（递归锁）

可重入锁的字面意思是“可以重新进入的锁”，即允许同一个线程多次获取同一把锁。

Reference：

+ https://zhuanlan.zhihu.com/p/71156910
+ https://zhuanlan.zhihu.com/p/451061367
+ https://xie.infoq.cn/article/d9479ba8900bd7645c035d006
